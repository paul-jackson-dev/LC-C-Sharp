Solution:

A solution is a container that holds different projects.

Typing:
Even though C# is a statically typed language, we can type variables as var and the compiler will infer the type. Aviod using var.

Built In Types: (primitive types)
In C#, all of the built in types are objects and have short names that break naming convention. We can also use the official .NET classname?

Short name	.NET Class	Examples	Notes
int		Int32		-5, 1024	
float		Single		1.212, 3.14	
double		Double		3.14159, 2.0	Doubles are twice as precise (i.e. can hold much longer decimal numbers than floats)
char		Char		‘a’, ‘!’	A single Unicode character. Must be enclosed in single quotes '' to be a character; double quotes "" indicate a string
bool		Boolean		true, false	Note that booleans in C# are not capitalized as they are in Python

Primitive types are immutable.


Non-primitive types
string is another built-in type in C# and it is also a non-primitive data type.

Numeric types such as int and double may be freely mixed when using numeric operators. 
Generally, the result of such mixing is that the output has the type of the more precise input. 

Reference and Value Types:
Value types: int, float, double, char, bool, (all other built in types)

Reference types: All Class Types. Dog myDog = new Dog();
Variables and parameters that are of the type of a class are said to be of reference type (in contrast to primitive type). In plain English, we would say of the C# example: “myDog is a reference variable of type Dog.
Classes define reference types. A variable of a reference type (such as myDog above) does not actually store the object in question. Instead, it stores a reference to the object. A reference is literally a memory address. We visualize references as an arrow pointing to the object in memory.

Boxing:
All types in C# are treated as objects. Even value types. This can be accomplished through processes called boxing and unboxing. Converting from a value type to a reference type is called boxing, and the reverse process (reference to value) is called unboxing. C# is known as a unified type system because it implicitly boxes values types to be treated as objects.

   int i = 123;     // This is a value type.
   object o = i;    // Boxing the value type into a reference type.
   int j = (int)o;  // Unboxing the reference type back into a value type.


using: (import statement)
The using statement in C# allows us to access classes, methods, and data stored in different files other than the one we are currently in.
assuming. 
	1. The C# compiler must know that the class exists.
	2. You must use the full name of the class.
Classes that are available may be those in the project you are currently working on, or those that come along with the .NET class library, as well as anything you might get from added dependencies.
System.Console can simply be access using Console. System is the namespace, Console is the class.

Input/Output:
Console.WriteLine can take parameters of various types, including string, char, double, bool, and others. We must manually concatenate strings or other values if we want to print a composite value.
   int year = 2020;
   Console.WriteLine("Hello" + "World")
   Console.WriteLine("The year is " + year.ToString());

Console.ReadLine returns input as a string.
To convert it to a desired type, you can generally use the syntax [TYPE].Parse(value
   string userInput = Console.ReadLine();
   int year = int.Parse(userInput); // use int type to cast parsed input

Strings, Characters, and Arrays:
Strings are immutable which means any given character cannot be changed.

String Methods:
@ initializes a string as a literal
string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";

C# Syntax		Description
str.Substring(3,1)	Returns the character in 3rd position, (a).
str.Substring(2,3)	Return substring from 2nd to 4th, i.e. substring starting at index 2 and 3 characters long, (tab).
str.Length		Tells us the length of the string, (8).
str.IndexOf('a')	Returns the index for the first occurrence of ‘a’, (3).
str.Split('a')		Splits the string into sections at each delimiter and stores the sections as elements in an array, ({Rut, b, g}).
str + str		Concatenate two strings together, (RutabagaRutabaga).
str.Trim()		Removes any whitespace at the beginning or end of the string, (Rutabaga — there’s not whitespace here).
str.ToUpper(), str.ToLower()	Changes all alphabetic characters in the string to UPPERCASE or lowercase, respectively,(RUTABAGA, rutabaga).

Arrays: (fixed size that cannot change)
int[] someInts = new int[10]; // stores an array of 10 integers
int[] someOtherInts = {1, 1, 2, 3, 5, 8}; // literal expression

Objects:
In C#, objects are structures that have a state and a set of behaviors. The state of an object includes properties/data that the coder can define and modify. Behaviors are actions that run when requested, and they can be used to evaluate, manipulate, or return data.

Static Methods:
Behave somewhat similarly to stand-alone functions. 
A static method is one that can be called without creating an object instance of the class to which it belongs.

Main() Methods:
Starting in .NET 6 the Main() method is synthesized.

Loops:

for Loop:
for (int i = 0; i < 10; i++ ) {
   Console.WriteLine(i);
}

foreach Loop:
int[] nums = {1, 1, 2, 3, 5, 8, 13, 21};

foreach (int n in nums) {
   Console.WriteLine(n);
}

string msg = "Hello World";

foreach (char c in msg.ToCharArray()) {
   Console.WriteLine(c);
}

while Loop:
int w = 0;
while (w < 3) {
   w++;
}

do-while Loop:
do {
   Console.WriteLine("Hello, World");
} while (false);

StringBuilder:
while something like sentence += word is fine, it can use a lot of resources if the sentence is long since strings are immutable and a new string object is created each iteration.
We can use the StringBuilder class to create a single object since it is mutable.

StringBuilder newFinalSentence = new StringBuilder();

foreach (string word in arrayOfWords) {
   newFinalSentence.Append(word);
}

Data Structures:
A data structure lets us hold on to lots of data in a single place. It is a programming construct to aggregate many values into one value. Many types of data structures exist in various languages. A few examples are lists, dictionaries, arrays, tuples, etc.

Collections:
using System.Collections.Generic;

List:
List<string> students = new List<string>();
students.Add(newStudent);
or 
List<string> newList = new List<string> {"Apples", "Oranges", "Avocados"};
students.Count // to get List length

List Methods in C#:
 .IndexOf()
 .Add()
 .Contains()
 .Sort()
 .ToArray()

Array:
Arrays are faster than List
int maxStudents = 30;
string[] students = new string[maxStudents];
students[i] = newStudent; // to add

Dictionary: Key/Value pair
Dictionary<string, double> students = new Dictionary<string, double>();
or 
Dictionary<int, string> groceries = new Dictionary<int, string>
{
   {2, "Apples"},
   {3, "Oranges"},
   {1, "Avocado"}
};
students.Add(newStudent, newGrade); // Key, Value

string name = "jesse";
double jesseGrade = students[name];

// for key and value
foreach (KeyValuePair<string, double> student in students) {
   Console.WriteLine(student.Key + " (" + student.Value + ")");
   sum += student.Value;
}

// for key
foreach (string studentName in students.Keys) {
   Console.WriteLine(studentName);
}

// for value
foreach (double grade in students.Values) {
   Console.WriteLine(grade);
}

Dictionary Methods in C#:
.Count
.Keys
.Values
.Add()
.ContainsKey()
.ContainsValue()

Access Modifiers:

Modifier			Class	Assembly	World
public				Yes	Yes		Yes
protected			Yes	No		No
internal (default for classes)	Yes	Yes		No
protected internal		Yes	Yes		No
private (default for class members)Yes	No		No

In C#, an assembly refers to a grouping of classes and other resources that form a particular unit of an application.
World-level is the level of the whole application and contains all of the packages and classes.
Getter setter methods are also often called accessors.

Getters Setters / Accessors:
   private string name;

   public string Name
   {
      get { return name; } // default is public?
      internal set { name = value; } // only set by class or assembly
   }

Example of Setter Validation: // throw ArgumentException
   public class Temperature 
   {

      private double fahrenheit;

      public double Fahrenheit
      {
         get
         {
            return fahrenheit;
         }

        set
        {
            double absoluteZeroFahrenheit = -459.67;

            if (value < absoluteZeroFahrenheit) 
            {
               throw new ArgumentException("Value is below absolute zero");
            }

            fahrenheit = value;
         }
      }
   }

Properties:
A property in C# is a characteristic that users can set. Most often, properties will correspond directly to a private backing field, but they don’t have to. 
   public double Celsius
   {
      get { return (Fahrenheit - 32) * 5.0 / 9.0; }
      set { Fahrenheit = value * 9.0 / 5.0 + 32; }
   }

Auto-Implemented Properties:
public string Name { get; set; } // shorthand if we don't need validation

This is referred to as an auto-implemented property. When a property is auto-implemented, the compiler creates a private field that can only be accessed through the property’s get and set accessors.
Note that in this example, the private field is name (lowercase) while the property is Name. Since C# identifiers are case-sensitive, these are two distinct members. name is referred to as a backing field, and it stores the value of the property.

Constructor Overloading: // providing different constructors for different scenarios
	
   public class Student 
   {

      public string Name { get; set; }
      public int StudentId { get; set; }
      public int NumberOfCredits { get; set; }
      public double Gpa { get; set; }

      public Student(string name, int studentId, int numberOfCredits, double gpa) 
      {
         Name = name;
         StudentId = studentId;
         NumberOfCredits = numberOfCredits;
         Gpa = gpa;
      }

      public Student(string name, int studentId) : this(name, studentId, 0, 0.0) {} // use this to call other constuctor, inheritance

   }

Instance Method with Constructor Overloading:
	
   public class Student 
   {

      private static int nextStudentId = 1;
      public string Name { get; set; }
      public int StudentId { get; set; }
      public int NumberOfCredits { get; set; }
      public double Gpa { get; set; }

      public Student(string name, int studentId,
            int numberOfCredits, double gpa)
      {
         Name = name;
         StudentId = studentId;
         NumberOfCredits = numberOfCredits;
         Gpa = gpa;
      }

      public Student(string name, int studentId)
        : this(name, studentId, 0, 0) {}

      public Student(string name) 
         : this(name, nextStudentId)
      {
         nextStudentId++;
      }

      public string StudentInfo() 
      {
         return (Name + " has a GPA of: " + Gpa);
      }

   }

Single Responsibility Principle:
The single responsibility principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class.


Readonly Fields:
A readonly field is one that cannot be changed once it is initialized. This means slightly different things for value and reference types. We create readonly fields by declaring them with the readonly keyword.

We cannot change the value of a readonly value field (readonly int, readonly double, etc.) after it is initialized.

Similarly, we cannot assign a new object to a readonly reference field (readonly ClassName, for example) after initialization. However, because objects are reference types and not value types, we can change the values within the object itself.

Const:
There is no strong reason to make constants private, since restricting access would force us to re-declare the same values in different classes. We’ll generally make our constants public.

We must declare and initialize a constant at the same time. If we do not declare and initialize the constant in the same statement, we cannot assign it a value later. The constant’s value remains empty

Const vs Readonly:
Const is a compile-time constant, while readonly is a runtime constant. Const values are implicitly static and limited to basic types, while readonly variables can be instance, static, or reference types. Const variables are stored in metadata and readonly variables are stored in the memory heap.

Instance Methods:
Instance methods define the behaviors that are unique or specialized to each class. Every object created from a class will carry a copy of these methods.
Instance methods depend on the data stored in an individual object. If two objects call the same method, the results will vary when the objects contain different data.

Static Methods:
Just like static fields, static methods belong to the class as a whole, and not to any of the specific instances of the class. Thus, they are sometimes also called class methods. A static method is essentially the opposite of an instance method, since the two cases are mutually exclusive. Instance methods rely on each object’s specific data, while static methods must NOT rely on data from a specific object.

It is technically allowed to call a static method using an instance of a class: myObject.SomeStaticMethod(). However, best practice recommends using the class name instead: ClassName.SomeStaticMethod(). This makes it clear to other coders that you are calling a static method.

Equals():
If we don’t provide our own Equals() method, the default option only considers two objects equal if they are the exact same object, which means they point to the same memory address. This is identical to the behavior we see when using the == operator: bono1 == bono2.
The default Equals() method and the == operator test for identity, whereas we want to test for equality instead. We can do so by overriding the Equals() method.

	
public override boolean Equals(object toBeCompared) {

   if (toBeCompared == this)
   {
      return true;
   }

   if (toBeCompared == null)
   {
      return false;
   }

   if (toBeCompared.GetType() != this.GetType())
   {
      return false;
   }

   Student s = toBeCompared as Student;
   return s.StudentId == StudentId;
}

Reference check: If the two objects are the same, return true right away.
Null check: If the argument is null, return false.
Class check: Compare the classes of the two objects to ensure a safe cast. Return false if the classes are different.
Cast: Convert the argument to the type of our class, so getters and other methods can be called.
Custom comparison: Use custom logic to determine whether or not the two objects should be considered equal. This will usually be a comparison of class members.

Auto-Generated .Equals():
   public override bool Equals(object obj)
   {
      return obj is Course course && // With is, the compiler confirms that it is possible to cast obj to a variable course of type Course. If it is, the value of course is set to obj.
         Topic == course.Topic &&
         EqualityComparer<Teacher>.Default.Equals(Instructor, course.Instructor);
   }

Cast/Casting: //example
Student s = toBeCompared as Student;


MSTest:
MSTest is a framework that provides the methods and assertions for writing and executing unit tests in C#.

[TestClass]
[TestMethod]
[TestInitialize] // create new object that is persistent
[TestCleanup]

  [TestInitialize]
   public void CreateCarObject()
   {
      test_car = new Car("Toyota", "Prius", 10, 50);
   }

Common Assert Methods:

Assertion					Description
AreEqual(expected, actual, optional_delta)	Asserts that two values, expected and actual, are equal to each other (optionally, within a given range of difference)
IsFalse(condition)				Asserts that a given condition is false
IsTrue(condition)				Asserts that a given condition is true
IsNotNull(object)				Asserts that a given object is not null


Example of expecting an exception:
    [TestMethod]
    [ExpectedException(typeof(ArgumentOutOfRangeException))]
    public void TestGasOverfillException()
    {
        test_car.AddGas(16);
        Assert.Fail("Shouldn't get here, car cannot have more gas in tank than the size of the tank");
    }
}

Inheritance: (subtyping)
Here’s a definition: inheritance is a mechanism within object-oriented programming that allows one class to be based on another class, thus receiving its properties and behaviors.

// superclass, base class, or parent class
public class Cat
{
   // ...code for the Cat class...
}

// subclass, derived class, or child class of Cat
public class HouseCat : Cat // extends Cat
{
   // ...code for the HouseCat class...
}

base: // for constructors
public Cat(double weight)
{
   Weight = weight;
}

public HouseCat(string name, double weight) : base(weight)
{
   Name = name;
}

override and virtual:
When we override it, we should use override in the signature of the method in the subclass and virtual in the signature of the base class.

// in Cat, base class
public virtual string Noise()
{
   return "Meow!";
}

// in HouseCat, subclass
public override string Noise()
{
   return "Hello, my name is " + Name + "!";
}

To call the base class method:
it needs to be called from within the subclass.
base.Noise()

Inheriting from Abstraction: // abstract class
Abstraction prevents a base class object from being created.

public abstract class Cat
{
   // Cat class definition
}

abstract Methods:
An abstract method is a method in an abstract class that does not have a body. In other words, it does not have any associated code, only a signature. It must also be marked abstract
By creating this abstract method, we force any class that extends Cat to provide its own implementation of that behavior.

Casting:
When one class extends another, as HouseCat extends Cat, a field or local variable of the type of the base class may hold an object that is of the type of the child class.
Cat suki = new HouseCat("Suki", 8);
when we call methods on such an object, the compiler is smart enough to determine which method it should call. For example, the following call to Noise() will call the version defined in HouseCat:
This only works for methods that are declared in the base class, however. If we have a HouseCat object stored in a Cat variable or field, then it is not allowed to call methods that are only part HouseCat.
//here we cast Cat to HouseCat to access a subclass method that isn't defined in the base class.
(suki as HouseCat).IsSatisfied();

Storing objects of one type (e.g. HouseCat) in a variable or field of another compatible type (e.g. Cat) is an example of polymorphism. Polymorphism is another one of the pillars of OOP and we’ll have more to say about it in the next lesson.

Polymorphism:
Polymorphism is an object-oriented mechanism that allows for objects of different types to be used in the same way.

Interfaces:
An interface is similar to an abstract class, with some important differences. Interfaces allow us to create code organized by behavior, rather than static data. While some object-oriented languages encourage creating classes that behave like interfaces to improve software design, C# is a language that includes interfaces as a formal construction. Like abstract classes, interfaces cannot be instantiated and they have limitations on what kind of behavioral information they may contain. A C# interface may contain:

Constants
Method signatures
Static methods
Default methods

	
   public interface IFeedable
   {

      void Eat(); // method signature, no access modifier

   }

Static Methods in interfaces:
A static method in an interface can contain code in the body. However, a static method cannot contain any references to instance properties in other classes. This means that our static methods should only deal with universal behaviors that are NOT dependent on instance properties.

Default Methods in interfaces:
A default method has a body and is a fully-formed method. It may be extended by classes implementing the interface.

Extend a class and implement an interface:
  public class HouseCat : Cat, IPetable
   {
      // ^^ Note that order matters here. The class being extended 
      // must come before any interfaces being implemented
   }

Benefits of Using Interfaces:
Once you get used to interfaces, you’ll begin to think more abstractly about which behaviors your code requires rather than which classes your code requires. This means you will start to “code to interfaces” (an OOP principle) instead of coding to classes, and your code will become more flexible and extensible.

Here are a few benefits of using interfaces:

You can only extend one class, but you may implement many interfaces.
You can extend a class and implement an interface at the same time.
By declaring variables and parameters as interface types, you make your code useful for a much wider variety of situations.
When you declare properties and return types to be interface types, you decouple code using your classes from the actual class types you use. This means that you are free to change the specific implementation of your classes without affecting those using them.

Interfaces and Abstract Classes:
We mentioned previously that interfaces share some characteristics with abstract classes. Recall that an abstract class is one declared with the abstract keyword. You may not create an object from an abstract class and, like an interface, an abstract class is allowed to contain methods that only have signatures (that is, methods that don’t have implementation code).

The main differences between interfaces and abstract classes are:

You implement an interface, while you extend an abstract class. The net effect of this is that a class may implement interfaces while also extending a class. Note that while you can implement more than one interface, you can only extend one class.

Abstract classes may contain non-constant fields, while interfaces can only contain constant fields.

Abstract classes should be used to collect and specify behavior by related classes, while an interface should be used to specify related behaviors that may be common across unrelated classes

Some of the most used interfaces:

IComparer<T>
Purpose: A class implements this interface to compare two objects of a given class. This is a parameterized interface, which means that when using it, you need to specify the class that it will be comparing. For example, IComparer<Job> would compare Job objects.

Important Methods and Properties: Compare(T, T)

IComparer.Compare Documentation

This interface can be used to determine, given two objects of the given type, which one is greater than the other. It is also used by collections such as List to sort its contents with the Sort method.

Using IComparer<T> is a two step process. You must first create a class that implements the interface. Then, provide a custom implementation of the Compare method.

   public class JobComparer : IComparer<Job>
   {
      public int Compare(Job x, Job y)
      {
         // ^^ This Compare method is an implementation of IComparer.Compare
         // Here, we write our own logic for comparing two job objects.
         // For example, if we want to compare Job objects by name values, we'd write:
         return string.Compare(x.Name, y.Name);
         // ^^ Note, this Compare method is the built-in string method
         // if we want to compare Jobs based on multiple fields, we can do so by expanding the custom logic
         // in this ``IComparer.Compare`` implementation
      }
   }
Compare(T, T) returns an integer which determines which of the two objects comes before (in other words, “is less than”) the other. If the returned value is less than zero, then the first parameter comes before the second. If the integer is zero, then they are considered the same. If the integer is greater than zero, then the second parameter comes before the first.

You can think of the result of calling Compare(x, y) as being the value of subtracting, like x - y. If x is smaller than y, this value is negative. If x is larger than y, this value is positive.

IEnumerable<T>
Purpose: Enable iteration over a collection of objects using foreach.

Important Methods and Properties: MoveNext(), Current

IEnumerable Documentation

This interface is implemented by the List<T> class, which we’ve been using throughout this course.
IEnumerable<string> collection = new List<string>();

   // add items to the collection

   foreach (string item in collection) 
   {
      // do something with the item
   }

IList<T>
Purpose: Enable access to objects in a collection by index.

Important Methods and Properties: Add(T), Contains(T), Remove(T), Count

IList Documentation

This interface is also implemented by the List<T> class, which we’ve been using throughout this course. In fact, IList<T> extends IEnumerable<T>. An interface may extend another interface, in the same way that classes may extend each other.
IList<string> collection = new List<string>();

   // Add items to the collection

   string firstItem = collection[0];

IDictionary<TKey, TValue>
Purpose: Represent a collection of key/value pairs.

Important Methods and Properties: Add(TKey, TValue), Contains(T), Remove(T), Count, Keys, Values

IDictionary Documentation

This interface is implemented by the Dictionary<TKey, TValue> class, which we’ve been using throughout this course.
IDictionary<string, string> collection = new Dictionary<string, string>();

   // Add items to the collection

   // Get item with key "hello"
   string hello = collection["hello"];


ASP.NET: (ASP.NET Core MVC)
.NET version of MVC

Controllers and Static Responses:
public class HelloController : Controller
   {

      // class code here ...

   }

Conventional Routing:
localhost:5001/<controller>/<action> // in Program.cs
localhost:5001/home/index   // where Index calls Index()

Attribute Routing: 
Attribute Routing uses Action Methods.
Action Methods are public methods in a controller class.
attributes in C# lie somewhere between code and comments

HTTP verb attributes
[HttpGet]
[HttpPost]

IActionResult:
IActionResult is an interface in the ASP.NET framework and often times the return type of action methods. When we specify the return type as IActionResult, the returned value dictates what the client will display after the action is complete. We can use IActionResult to get the client to display plain text or other data types. In a later section on views, we will use IActionResult to return HTML templates. We will only scratch the surface of what IActionResult can do so for now, let’s focus on Content. Content is a class that implements the IActionResult interface.

class HelloController : Controller
   {
      [HttpGet] // HTTP verb attribute
      [Route("/helloworld/")] // Routing attribute
      public IActionResult Index() //IActionResult is an interface type
      {
         string html = "<h1>" + "Hello World!" + "<h1>";
         return Content(html, "text/html"); // Content is a class that implements IActionResult
      }
   }

Query Strings are URL Data:
www.galaxyglossary.net?aKey=aValue&anotherKey=anotherValue&thirdKey=thirdValue  // key/value pairs
localhost:5001/helloworld/welcome?name=Tillie

   [HttpGet]
   [Route("/helloworld/welcome/{name?}")] // query string name is optional ?
   public IActionResult Welcome(string name = "World") // name has a default value in case a query string is not passed in
   {
      return Content("<h1>Welcome to my app, " + name + "!</h1>", "text/html");
   }

Path Variables:
Path variables differ from query strings in that the data is not passed in as a key-value pair and that a path variable is a portion of the URL path.
[Route("/helloworld/welcome/{name?}")] // also allows for path variables.
example: localhost:5001/helloworld/welcome/Tillie
This is because name is a route parameter
A route parameter is a portion of the route (which encompasses both the path and the query string) that is passed from the route to the action method.

Class-Level Attributes:
	
    [Route("/helloworld")]
    public class HelloController : Controller
    {
        // action methods here
    }

One Method, Two Request Types:
allows for Get Requests at,
localhost:5001/helloworld/welcome // returns default name
localhost:5001/helloworld/welcome?name=Tillie // accepts query string for name
localhost:5001/helloworld/welcome/Tille // uses path variable for name

and Post request at, 
localhost:5001/helloworld/welcome


   [HttpGet("welcome/{name?}")]
   [HttpPost("welcome")]
   public IActionResult Welcome(string name = "World")
   {
      return Content("<h1>Welcome to my app, " + name + "!</h1>", "text/html");
   }

Exceptions:
System.Exception
Exceptions in C# are objects derived from the System.Exception class. 
public Temperature(double fahrenheit)
{
   try
   {
      Fahrenheit = fahrenheit;
   }
   catch(ArgumentOutOfRangeException e)
   {
      Fahrenheit = -459.67;
   }
   catch() // multiple catches are allowed, exception swallowing
   {
      Fahrenheit = -459.67;
   }
   finally
   {
      Console.WriteLine("Fahrenheit cannot be less than -459.67.");
   }
}

Common Exception Types:
 ArgumentOutOfRangeException
 ArgumentNullException
 IndexOutOfRangeException
 InvalidOperationException
 NullReferenceException


Razor Views: (templating language)
Razor is a templating syntax included in the application framework for our MVC project. It allows us to write C# code directly into an HTML tree.

Out of the box, your MVC project contains several Razor templates within the Views directory. The sub-directory Home, found inside of Views, contains the Razor templates returned from the HomeController action methods. Just as an action method’s name will map to a route with the same name, an action method’s name can also correspond to a Razor template’s name

The Index() method inside of HomeController returns the Index.cshtml template found inside of Views/Home.

You can override the default behavior of the View() method, you can pass in a parameter which is the name of the template you want to render. For example, if we want an action method named Form() to return a Razor template named WelcomeForm.cshtml, we have Form() return View("WelcomeForm");

We are going to name the Views after their corresponding action methods for the MVC projects in this course. Index()


_Layout.cshtml:
This file adds styling to pages automatically.
We can change it or remove it from our pages.
//inside the Views/Hello/Index.cshtml
@{
   Layout = null;
}

Passing Data to a Template:
ViewBag is an object that passes data into a template.
You can think of ViewBag as like an empty container object who exists for the purpose of carrying variables from the controller into the view.
	
  public IActionResult ActionMethod()
  {
     // method code here

     ViewBag.property = Data;
     return View();
  }

Accessing Data in a Template:
<p>@ViewBag.vegetable</p>
<h1>Welcome, @ViewBag.person!</h1>

Iterating in a Template:
<ol>
   @foreach (string coffeeType in ViewBag.coffeeOptions)
   {
      <li>@coffeeType</li>
   }
</ol>

We can use var for implied typing for custom types/classes:
We can also import custom classes at the top of the template with a using statement.
	
@foreach (var coffeeShop in ViewBag.coffeeShops)
{
   @*Each shop name*@
   <p>@coffeeShop.Name</p>
   <ul>
      @foreach(string coffeeType in coffeeShop.CoffeeOptions)
      {
         @*Each coffee type available*@
         <li>@coffeeType</li>
      }
   </ul>
}

Conditionals in a template:
@if (ViewBag.userSelection == "Instant")
{
   <p>Are you sure about that?</p>
}
else if (ViewBag.userSelection == "French Roast")
{
   <p>Oooh la la!</p>
}
else
{
   <p>Thanks for your order</p>
}

Razor Forms: //start coding events
<form method="post">
   <input name="name" type="text" />
   <input type="submit" value="Add Event" />
</form>

Usage of redirect after form data is caught:
[HttpPost]
[Route("/Events/Add")]
public IActionResult NewEvent (string name)
{
   // Method code ...
   return Redirect("/Events");
}

Anchor Tags: // for linking
<a asp-controller="ControllerName" asp-action="ViewName">Text Here</a>

Marking a Partial View: // fragments
_LinkListPartial.cshtml

<a href = "https://www.launchcode.org">LaunchCode</a> <br/>
<a href = "https://www.lego.com">Play Well</a> <br/>
<a href = "https://www.webelements.com">Other Building Blocks</a>

<!-- template code -->

<partial name="/Views/Shared/_LinkListPartial.cshtml" />

<!-- more template code -->


wwwroot is the default location for static files




































