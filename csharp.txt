Solution:

A solution is a container that holds different projects.

Typing:
Even though C# is a statically typed language, we can type variables as var and the compiler will infer the type. Aviod using var.

Built In Types: (primitive types)
In C#, all of the built in types are objects and have short names that break naming convention. We can also use the official .NET classname?

Short name	.NET Class	Examples	Notes
int		Int32		-5, 1024	
float		Single		1.212, 3.14	
double		Double		3.14159, 2.0	Doubles are twice as precise (i.e. can hold much longer decimal numbers than floats)
char		Char		‘a’, ‘!’	A single Unicode character. Must be enclosed in single quotes '' to be a character; double quotes "" indicate a string
bool		Boolean		true, false	Note that booleans in C# are not capitalized as they are in Python

Primitive types are immutable.


Non-primitive types
string is another built-in type in C# and it is also a non-primitive data type.

Numeric types such as int and double may be freely mixed when using numeric operators. 
Generally, the result of such mixing is that the output has the type of the more precise input. 

Reference and Value Types:
Value types: int, float, double, char, bool, (all other built in types)

Reference types: All Class Types. Dog myDog = new Dog();
Variables and parameters that are of the type of a class are said to be of reference type (in contrast to primitive type). In plain English, we would say of the C# example: “myDog is a reference variable of type Dog.
Classes define reference types. A variable of a reference type (such as myDog above) does not actually store the object in question. Instead, it stores a reference to the object. A reference is literally a memory address. We visualize references as an arrow pointing to the object in memory.

Boxing:
All types in C# are treated as objects. Even value types. This can be accomplished through processes called boxing and unboxing. Converting from a value type to a reference type is called boxing, and the reverse process (reference to value) is called unboxing. C# is known as a unified type system because it implicitly boxes values types to be treated as objects.

   int i = 123;     // This is a value type.
   object o = i;    // Boxing the value type into a reference type.
   int j = (int)o;  // Unboxing the reference type back into a value type.


using: (import statement)
The using statement in C# allows us to access classes, methods, and data stored in different files other than the one we are currently in.
assuming. 
	1. The C# compiler must know that the class exists.
	2. You must use the full name of the class.
Classes that are available may be those in the project you are currently working on, or those that come along with the .NET class library, as well as anything you might get from added dependencies.
System.Console can simply be access using Console. System is the namespace, Console is the class.

Input/Output:
Console.WriteLine can take parameters of various types, including string, char, double, bool, and others. We must manually concatenate strings or other values if we want to print a composite value.
   int year = 2020;
   Console.WriteLine("Hello" + "World")
   Console.WriteLine("The year is " + year.ToString());

Console.ReadLine returns input as a string.
To convert it to a desired type, you can generally use the syntax [TYPE].Parse(value
   string userInput = Console.ReadLine();
   int year = int.Parse(userInput); // use int type to cast parsed input

Strings, Characters, and Arrays:
Strings are immutable which means any given character cannot be changed.

String Methods:
@ initializes a string as a literal
string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";

C# Syntax		Description
str.Substring(3,1)	Returns the character in 3rd position, (a).
str.Substring(2,3)	Return substring from 2nd to 4th, i.e. substring starting at index 2 and 3 characters long, (tab).
str.Length		Tells us the length of the string, (8).
str.IndexOf('a')	Returns the index for the first occurrence of ‘a’, (3).
str.Split('a')		Splits the string into sections at each delimiter and stores the sections as elements in an array, ({Rut, b, g}).
str + str		Concatenate two strings together, (RutabagaRutabaga).
str.Trim()		Removes any whitespace at the beginning or end of the string, (Rutabaga — there’s not whitespace here).
str.ToUpper(), str.ToLower()	Changes all alphabetic characters in the string to UPPERCASE or lowercase, respectively,(RUTABAGA, rutabaga).

Arrays: (fixed size that cannot change)
int[] someInts = new int[10]; // stores an array of 10 integers
int[] someOtherInts = {1, 1, 2, 3, 5, 8}; // literal expression

Objects:
In C#, objects are structures that have a state and a set of behaviors. The state of an object includes properties/data that the coder can define and modify. Behaviors are actions that run when requested, and they can be used to evaluate, manipulate, or return data.

Static Methods:
Behave somewhat similarly to stand-alone functions. 
A static method is one that can be called without creating an object instance of the class to which it belongs.

Main() Methods:
Starting in .NET 6 the Main() method is synthesized.

Loops:

for Loop:
for (int i = 0; i < 10; i++ ) {
   Console.WriteLine(i);
}

foreach Loop:
int[] nums = {1, 1, 2, 3, 5, 8, 13, 21};

foreach (int n in nums) {
   Console.WriteLine(n);
}

string msg = "Hello World";

foreach (char c in msg.ToCharArray()) {
   Console.WriteLine(c);
}

while Loop:
int w = 0;
while (w < 3) {
   w++;
}

do-while Loop:
do {
   Console.WriteLine("Hello, World");
} while (false);

StringBuilder:
while something like sentence += word is fine, it can use a lot of resources if the sentence is long since strings are immutable and a new string object is created each iteration.
We can use the StringBuilder class to create a single object since it is mutable.

StringBuilder newFinalSentence = new StringBuilder();

foreach (string word in arrayOfWords) {
   newFinalSentence.Append(word);
}

Data Structures:
A data structure lets us hold on to lots of data in a single place. It is a programming construct to aggregate many values into one value. Many types of data structures exist in various languages. A few examples are lists, dictionaries, arrays, tuples, etc.

Collections:
using System.Collections.Generic;

List:
List<string> students = new List<string>();
students.Add(newStudent);
or 
List<string> newList = new List<string> {"Apples", "Oranges", "Avocados"};
students.Count // to get List length

List Methods in C#:
 .IndexOf()
 .Add()
 .Contains()
 .Sort()
 .ToArray()

Array:
Arrays are faster than List
int maxStudents = 30;
string[] students = new string[maxStudents];
students[i] = newStudent; // to add

Dictionary: Key/Value pair
Dictionary<string, double> students = new Dictionary<string, double>();
or 
Dictionary<int, string> groceries = new Dictionary<int, string>
{
   {2, "Apples"},
   {3, "Oranges"},
   {1, "Avocado"}
};
students.Add(newStudent, newGrade); // Key, Value

string name = "jesse";
double jesseGrade = students[name];

// for key and value
foreach (KeyValuePair<string, double> student in students) {
   Console.WriteLine(student.Key + " (" + student.Value + ")");
   sum += student.Value;
}

// for key
foreach (string studentName in students.Keys) {
   Console.WriteLine(studentName);
}

// for value
foreach (double grade in students.Values) {
   Console.WriteLine(grade);
}

Dictionary Methods in C#:
.Count
.Keys
.Values
.Add()
.ContainsKey()
.ContainsValue()

Access Modifiers:

Modifier			Class	Assembly	World
public				Yes	Yes		Yes
protected			Yes	No		No
internal (default for classes)	Yes	Yes		No
protected internal		Yes	Yes		No
private (default for class members)Yes	No		No

In C#, an assembly refers to a grouping of classes and other resources that form a particular unit of an application.
World-level is the level of the whole application and contains all of the packages and classes.
Getter setter methods are also often called accessors.

Getters Setters / Accessors:
   private string name;

   public string Name
   {
      get { return name; } // default is public?
      internal set { name = value; } // only set by class or assembly
   }

Example of Setter Validation: // throw ArgumentException
   public class Temperature 
   {

      private double fahrenheit;

      public double Fahrenheit
      {
         get
         {
            return fahrenheit;
         }

        set
        {
            double absoluteZeroFahrenheit = -459.67;

            if (value < absoluteZeroFahrenheit) 
            {
               throw new ArgumentException("Value is below absolute zero");
            }

            fahrenheit = value;
         }
      }
   }

Properties:
A property in C# is a characteristic that users can set. Most often, properties will correspond directly to a private backing field, but they don’t have to. 
   public double Celsius
   {
      get { return (Fahrenheit - 32) * 5.0 / 9.0; }
      set { Fahrenheit = value * 9.0 / 5.0 + 32; }
   }

Auto-Implemented Properties:
public string Name { get; set; } // shorthand if we don't need validation

This is referred to as an auto-implemented property. When a property is auto-implemented, the compiler creates a private field that can only be accessed through the property’s get and set accessors.
Note that in this example, the private field is name (lowercase) while the property is Name. Since C# identifiers are case-sensitive, these are two distinct members. name is referred to as a backing field, and it stores the value of the property.

Constructor Overloading: // providing different constructors for different scenarios
	
   public class Student 
   {

      public string Name { get; set; }
      public int StudentId { get; set; }
      public int NumberOfCredits { get; set; }
      public double Gpa { get; set; }

      public Student(string name, int studentId, int numberOfCredits, double gpa) 
      {
         Name = name;
         StudentId = studentId;
         NumberOfCredits = numberOfCredits;
         Gpa = gpa;
      }

      public Student(string name, int studentId) : this(name, studentId, 0, 0.0) {} // use this to call other constuctor, inheritance

   }

Instance Method with Constructor Overloading:
	
   public class Student 
   {

      private static int nextStudentId = 1;
      public string Name { get; set; }
      public int StudentId { get; set; }
      public int NumberOfCredits { get; set; }
      public double Gpa { get; set; }

      public Student(string name, int studentId,
            int numberOfCredits, double gpa)
      {
         Name = name;
         StudentId = studentId;
         NumberOfCredits = numberOfCredits;
         Gpa = gpa;
      }

      public Student(string name, int studentId)
        : this(name, studentId, 0, 0) {}

      public Student(string name) 
         : this(name, nextStudentId)
      {
         nextStudentId++;
      }

      public string StudentInfo() 
      {
         return (Name + " has a GPA of: " + Gpa);
      }

   }

Single Responsibility Principle:
The single responsibility principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class.


Readonly Fields:
A readonly field is one that cannot be changed once it is initialized. This means slightly different things for value and reference types. We create readonly fields by declaring them with the readonly keyword.

We cannot change the value of a readonly value field (readonly int, readonly double, etc.) after it is initialized.

Similarly, we cannot assign a new object to a readonly reference field (readonly ClassName, for example) after initialization. However, because objects are reference types and not value types, we can change the values within the object itself.

Const:
There is no strong reason to make constants private, since restricting access would force us to re-declare the same values in different classes. We’ll generally make our constants public.

We must declare and initialize a constant at the same time. If we do not declare and initialize the constant in the same statement, we cannot assign it a value later. The constant’s value remains empty

Const vs Readonly:
Const is a compile-time constant, while readonly is a runtime constant. Const values are implicitly static and limited to basic types, while readonly variables can be instance, static, or reference types. Const variables are stored in metadata and readonly variables are stored in the memory heap.

Instance Methods:
Instance methods define the behaviors that are unique or specialized to each class. Every object created from a class will carry a copy of these methods.
Instance methods depend on the data stored in an individual object. If two objects call the same method, the results will vary when the objects contain different data.

Static Methods:
Just like static fields, static methods belong to the class as a whole, and not to any of the specific instances of the class. Thus, they are sometimes also called class methods. A static method is essentially the opposite of an instance method, since the two cases are mutually exclusive. Instance methods rely on each object’s specific data, while static methods must NOT rely on data from a specific object.

It is technically allowed to call a static method using an instance of a class: myObject.SomeStaticMethod(). However, best practice recommends using the class name instead: ClassName.SomeStaticMethod(). This makes it clear to other coders that you are calling a static method.

Equals():
If we don’t provide our own Equals() method, the default option only considers two objects equal if they are the exact same object, which means they point to the same memory address. This is identical to the behavior we see when using the == operator: bono1 == bono2.
The default Equals() method and the == operator test for identity, whereas we want to test for equality instead. We can do so by overriding the Equals() method.

	
public override boolean Equals(object toBeCompared) {

   if (toBeCompared == this)
   {
      return true;
   }

   if (toBeCompared == null)
   {
      return false;
   }

   if (toBeCompared.GetType() != this.GetType())
   {
      return false;
   }

   Student s = toBeCompared as Student;
   return s.StudentId == StudentId;
}

Reference check: If the two objects are the same, return true right away.
Null check: If the argument is null, return false.
Class check: Compare the classes of the two objects to ensure a safe cast. Return false if the classes are different.
Cast: Convert the argument to the type of our class, so getters and other methods can be called.
Custom comparison: Use custom logic to determine whether or not the two objects should be considered equal. This will usually be a comparison of class members.

Auto-Generated .Equals():
   public override bool Equals(object obj)
   {
      return obj is Course course && // With is, the compiler confirms that it is possible to cast obj to a variable course of type Course. If it is, the value of course is set to obj.
         Topic == course.Topic &&
         EqualityComparer<Teacher>.Default.Equals(Instructor, course.Instructor);
   }

Cast/Casting: //example
Student s = toBeCompared as Student;


MSTest:
MSTest is a framework that provides the methods and assertions for writing and executing unit tests in C#.

[TestClass]
[TestMethod]
[TestInitialize] // create new object that is persistent
[TestCleanup]

  [TestInitialize]
   public void CreateCarObject()
   {
      test_car = new Car("Toyota", "Prius", 10, 50);
   }

Common Assert Methods:

Assertion					Description
AreEqual(expected, actual, optional_delta)	Asserts that two values, expected and actual, are equal to each other (optionally, within a given range of difference)
IsFalse(condition)				Asserts that a given condition is false
IsTrue(condition)				Asserts that a given condition is true
IsNotNull(object)				Asserts that a given object is not null


Example of expecting an exception:
    [TestMethod]
    [ExpectedException(typeof(ArgumentOutOfRangeException))]
    public void TestGasOverfillException()
    {
        test_car.AddGas(16);
        Assert.Fail("Shouldn't get here, car cannot have more gas in tank than the size of the tank");
    }
}

Inheritance: (subtyping)
Here’s a definition: inheritance is a mechanism within object-oriented programming that allows one class to be based on another class, thus receiving its properties and behaviors.

// superclass, base class, or parent class
public class Cat
{
   // ...code for the Cat class...
}

// subclass, derived class, or child class of Cat
public class HouseCat : Cat // extends Cat
{
   // ...code for the HouseCat class...
}

base: // for constructors
public Cat(double weight)
{
   Weight = weight;
}

public HouseCat(string name, double weight) : base(weight)
{
   Name = name;
}

override and virtual:
When we override it, we should use override in the signature of the method in the subclass and virtual in the signature of the base class.

// in Cat, base class
public virtual string Noise()
{
   return "Meow!";
}

// in HouseCat, subclass
public override string Noise()
{
   return "Hello, my name is " + Name + "!";
}

To call the base class method:
it needs to be called from within the subclass.
base.Noise()

Inheriting from Abstraction: // abstract class
Abstraction prevents a base class object from being created.

public abstract class Cat
{
   // Cat class definition
}

abstract Methods:
An abstract method is a method in an abstract class that does not have a body. In other words, it does not have any associated code, only a signature. It must also be marked abstract
By creating this abstract method, we force any class that extends Cat to provide its own implementation of that behavior.

Casting:
When one class extends another, as HouseCat extends Cat, a field or local variable of the type of the base class may hold an object that is of the type of the child class.
Cat suki = new HouseCat("Suki", 8);
when we call methods on such an object, the compiler is smart enough to determine which method it should call. For example, the following call to Noise() will call the version defined in HouseCat:
This only works for methods that are declared in the base class, however. If we have a HouseCat object stored in a Cat variable or field, then it is not allowed to call methods that are only part HouseCat.
//here we cast Cat to HouseCat to access a subclass method that isn't defined in the base class.
(suki as HouseCat).IsSatisfied();

Storing objects of one type (e.g. HouseCat) in a variable or field of another compatible type (e.g. Cat) is an example of polymorphism. Polymorphism is another one of the pillars of OOP and we’ll have more to say about it in the next lesson.

Polymorphism:
Polymorphism is an object-oriented mechanism that allows for objects of different types to be used in the same way.

Interfaces:
An interface is similar to an abstract class, with some important differences. Interfaces allow us to create code organized by behavior, rather than static data. While some object-oriented languages encourage creating classes that behave like interfaces to improve software design, C# is a language that includes interfaces as a formal construction. Like abstract classes, interfaces cannot be instantiated and they have limitations on what kind of behavioral information they may contain. A C# interface may contain:

Constants
Method signatures
Static methods
Default methods

	
   public interface IFeedable
   {

      void Eat(); // method signature, no access modifier

   }

Static Methods in interfaces:
A static method in an interface can contain code in the body. However, a static method cannot contain any references to instance properties in other classes. This means that our static methods should only deal with universal behaviors that are NOT dependent on instance properties.

Default Methods in interfaces:
A default method has a body and is a fully-formed method. It may be extended by classes implementing the interface.

Extend a class and implement an interface:
  public class HouseCat : Cat, IPetable
   {
      // ^^ Note that order matters here. The class being extended 
      // must come before any interfaces being implemented
   }

Benefits of Using Interfaces:
Once you get used to interfaces, you’ll begin to think more abstractly about which behaviors your code requires rather than which classes your code requires. This means you will start to “code to interfaces” (an OOP principle) instead of coding to classes, and your code will become more flexible and extensible.

Here are a few benefits of using interfaces:

You can only extend one class, but you may implement many interfaces.
You can extend a class and implement an interface at the same time.
By declaring variables and parameters as interface types, you make your code useful for a much wider variety of situations.
When you declare properties and return types to be interface types, you decouple code using your classes from the actual class types you use. This means that you are free to change the specific implementation of your classes without affecting those using them.

Interfaces and Abstract Classes:
We mentioned previously that interfaces share some characteristics with abstract classes. Recall that an abstract class is one declared with the abstract keyword. You may not create an object from an abstract class and, like an interface, an abstract class is allowed to contain methods that only have signatures (that is, methods that don’t have implementation code).

The main differences between interfaces and abstract classes are:

You implement an interface, while you extend an abstract class. The net effect of this is that a class may implement interfaces while also extending a class. Note that while you can implement more than one interface, you can only extend one class.

Abstract classes may contain non-constant fields, while interfaces can only contain constant fields.

Abstract classes should be used to collect and specify behavior by related classes, while an interface should be used to specify related behaviors that may be common across unrelated classes

Some of the most used interfaces:

IComparer<T>
Purpose: A class implements this interface to compare two objects of a given class. This is a parameterized interface, which means that when using it, you need to specify the class that it will be comparing. For example, IComparer<Job> would compare Job objects.

Important Methods and Properties: Compare(T, T)

IComparer.Compare Documentation

This interface can be used to determine, given two objects of the given type, which one is greater than the other. It is also used by collections such as List to sort its contents with the Sort method.

Using IComparer<T> is a two step process. You must first create a class that implements the interface. Then, provide a custom implementation of the Compare method.

   public class JobComparer : IComparer<Job>
   {
      public int Compare(Job x, Job y)
      {
         // ^^ This Compare method is an implementation of IComparer.Compare
         // Here, we write our own logic for comparing two job objects.
         // For example, if we want to compare Job objects by name values, we'd write:
         return string.Compare(x.Name, y.Name);
         // ^^ Note, this Compare method is the built-in string method
         // if we want to compare Jobs based on multiple fields, we can do so by expanding the custom logic
         // in this ``IComparer.Compare`` implementation
      }
   }
Compare(T, T) returns an integer which determines which of the two objects comes before (in other words, “is less than”) the other. If the returned value is less than zero, then the first parameter comes before the second. If the integer is zero, then they are considered the same. If the integer is greater than zero, then the second parameter comes before the first.

You can think of the result of calling Compare(x, y) as being the value of subtracting, like x - y. If x is smaller than y, this value is negative. If x is larger than y, this value is positive.

IEnumerable<T>
Purpose: Enable iteration over a collection of objects using foreach.

Important Methods and Properties: MoveNext(), Current

IEnumerable Documentation

This interface is implemented by the List<T> class, which we’ve been using throughout this course.
IEnumerable<string> collection = new List<string>();

   // add items to the collection

   foreach (string item in collection) 
   {
      // do something with the item
   }

IList<T>
Purpose: Enable access to objects in a collection by index.

Important Methods and Properties: Add(T), Contains(T), Remove(T), Count

IList Documentation

This interface is also implemented by the List<T> class, which we’ve been using throughout this course. In fact, IList<T> extends IEnumerable<T>. An interface may extend another interface, in the same way that classes may extend each other.
IList<string> collection = new List<string>();

   // Add items to the collection

   string firstItem = collection[0];

IDictionary<TKey, TValue>
Purpose: Represent a collection of key/value pairs.

Important Methods and Properties: Add(TKey, TValue), Contains(T), Remove(T), Count, Keys, Values

IDictionary Documentation

This interface is implemented by the Dictionary<TKey, TValue> class, which we’ve been using throughout this course.
IDictionary<string, string> collection = new Dictionary<string, string>();

   // Add items to the collection

   // Get item with key "hello"
   string hello = collection["hello"];


ASP.NET: (ASP.NET Core MVC)
.NET version of MVC

Controllers and Static Responses:
public class HelloController : Controller
   {

      // class code here ...

   }

Conventional Routing:
localhost:5001/<controller>/<action> // in Program.cs
localhost:5001/home/index   // where Index calls Index()

Attribute Routing: 
Attribute Routing uses Action Methods.
Action Methods are public methods in a controller class.
attributes in C# lie somewhere between code and comments

HTTP verb attributes
[HttpGet]
[HttpPost]

IActionResult:
IActionResult is an interface in the ASP.NET framework and often times the return type of action methods. When we specify the return type as IActionResult, the returned value dictates what the client will display after the action is complete. We can use IActionResult to get the client to display plain text or other data types. In a later section on views, we will use IActionResult to return HTML templates. We will only scratch the surface of what IActionResult can do so for now, let’s focus on Content. Content is a class that implements the IActionResult interface.

class HelloController : Controller
   {
      [HttpGet] // HTTP verb attribute
      [Route("/helloworld/")] // Routing attribute
      public IActionResult Index() //IActionResult is an interface type
      {
         string html = "<h1>" + "Hello World!" + "<h1>";
         return Content(html, "text/html"); // Content is a class that implements IActionResult
      }
   }

Query Strings are URL Data:
www.galaxyglossary.net?aKey=aValue&anotherKey=anotherValue&thirdKey=thirdValue  // key/value pairs
localhost:5001/helloworld/welcome?name=Tillie

   [HttpGet]
   [Route("/helloworld/welcome/{name?}")] // query string name is optional ?
   public IActionResult Welcome(string name = "World") // name has a default value in case a query string is not passed in
   {
      return Content("<h1>Welcome to my app, " + name + "!</h1>", "text/html");
   }

Path Variables:
Path variables differ from query strings in that the data is not passed in as a key-value pair and that a path variable is a portion of the URL path.
[Route("/helloworld/welcome/{name?}")] // also allows for path variables.
example: localhost:5001/helloworld/welcome/Tillie
This is because name is a route parameter
A route parameter is a portion of the route (which encompasses both the path and the query string) that is passed from the route to the action method.

Class-Level Attributes:
	
    [Route("/helloworld")]
    public class HelloController : Controller
    {
        // action methods here
    }

One Method, Two Request Types:
allows for Get Requests at,
localhost:5001/helloworld/welcome // returns default name
localhost:5001/helloworld/welcome?name=Tillie // accepts query string for name
localhost:5001/helloworld/welcome/Tille // uses path variable for name

and Post request at, 
localhost:5001/helloworld/welcome


   [HttpGet("welcome/{name?}")]
   [HttpPost("welcome")]
   public IActionResult Welcome(string name = "World")
   {
      return Content("<h1>Welcome to my app, " + name + "!</h1>", "text/html");
   }

Exceptions:
System.Exception
Exceptions in C# are objects derived from the System.Exception class. 
public Temperature(double fahrenheit)
{
   try
   {
      Fahrenheit = fahrenheit;
   }
   catch(ArgumentOutOfRangeException e)
   {
      Fahrenheit = -459.67;
   }
   catch() // multiple catches are allowed, exception swallowing
   {
      Fahrenheit = -459.67;
   }
   finally
   {
      Console.WriteLine("Fahrenheit cannot be less than -459.67.");
   }
}

Common Exception Types:
 ArgumentOutOfRangeException
 ArgumentNullException
 IndexOutOfRangeException
 InvalidOperationException
 NullReferenceException


Razor Views: (templating language)
Razor is a templating syntax included in the application framework for our MVC project. It allows us to write C# code directly into an HTML tree.

Out of the box, your MVC project contains several Razor templates within the Views directory. The sub-directory Home, found inside of Views, contains the Razor templates returned from the HomeController action methods. Just as an action method’s name will map to a route with the same name, an action method’s name can also correspond to a Razor template’s name

The Index() method inside of HomeController returns the Index.cshtml template found inside of Views/Home.

You can override the default behavior of the View() method, you can pass in a parameter which is the name of the template you want to render. For example, if we want an action method named Form() to return a Razor template named WelcomeForm.cshtml, we have Form() return View("WelcomeForm");

We are going to name the Views after their corresponding action methods for the MVC projects in this course. Index()


_Layout.cshtml:
This file adds styling to pages automatically.
We can change it or remove it from our pages.
//inside the Views/Hello/Index.cshtml
@{
   Layout = null;
}

Passing Data to a Template:
ViewBag is an object that passes data into a template.
You can think of ViewBag as like an empty container object who exists for the purpose of carrying variables from the controller into the view.
	
  public IActionResult ActionMethod()
  {
     // method code here

     ViewBag.property = Data;
     return View();
  }

Accessing Data in a Template:
<p>@ViewBag.vegetable</p>
<h1>Welcome, @ViewBag.person!</h1>

Iterating in a Template:
<ol>
   @foreach (string coffeeType in ViewBag.coffeeOptions)
   {
      <li>@coffeeType</li>
   }
</ol>

We can use var for implied typing for custom types/classes:
We can also import custom classes at the top of the template with a using statement.
	
@foreach (var coffeeShop in ViewBag.coffeeShops)
{
   @*Each shop name*@
   <p>@coffeeShop.Name</p>
   <ul>
      @foreach(string coffeeType in coffeeShop.CoffeeOptions)
      {
         @*Each coffee type available*@
         <li>@coffeeType</li>
      }
   </ul>
}

Conditionals in a template:
@if (ViewBag.userSelection == "Instant")
{
   <p>Are you sure about that?</p>
}
else if (ViewBag.userSelection == "French Roast")
{
   <p>Oooh la la!</p>
}
else
{
   <p>Thanks for your order</p>
}

Razor Forms: //start coding events
<form method="post">
   <input name="name" type="text" />
   <input type="submit" value="Add Event" />
</form>

Usage of redirect after form data is caught:
[HttpPost]
[Route("/Events/Add")]
public IActionResult NewEvent (string name)
{
   // Method code ...
   return Redirect("/Events");
}

Anchor Tags: // for linking
<a asp-controller="ControllerName" asp-action="ViewName">Text Here</a>

Marking a Partial View: // fragments
_LinkListPartial.cshtml

<a href = "https://www.launchcode.org">LaunchCode</a> <br/>
<a href = "https://www.lego.com">Play Well</a> <br/>
<a href = "https://www.webelements.com">Other Building Blocks</a>

<!-- template code -->

<partial name="/Views/Shared/_LinkListPartial.cshtml" />

<!-- more template code -->


wwwroot is the default location for static files

Models and Model Binding:
A model represents the logic for accessing and storing the data used in an application. // the business logic
example model: //type
   namespace CodingEventsDemo.Models
   {
      public class Event
      {
         public string Name { get; set; }
         public string Description { get; set; }

         public Event(string name, string description)
         {
            Name = name;
            Description = description;
         }

         public override string ToString()
         {
            return Name;
         }
      }
   }

Auto-Implement properties:
Here’s a shorthand to create auto-implementing properties. In a class, type the word “prop” followed by hitting the Tab key twice. This swiftly supplies the property’s scaffolding:
public string Description { get; set; }

Model Binding:
Model Binding requires an empty constructor.

For Model Binding to work form field names must match a model field name.
public IActionResult NewEvent(Event newEvent)

We can force fields to binding using [FromForm]	
   [FromForm(Name="desc")]	
   public string Description { get; set; }

Route Id:
/event/edit/1
<td><a asp-controller="Event" asp-action="Edit" asp-route-id="@evt.Id">Edit Event</a></td>

ViewModels and Passing Data Between Views:
A ViewModel is a model class designed specifically to be used in a view. By utilizing ViewModels in our application, we can make our views strongly-typed and add validation to forms to prevent bad user input. Also, if we have information we want to collect as part of a form, but not save as part of a model, we can store that data as a property of a ViewModel
These benefits of ViewModels will help reduce potential errors in our application.

namespace CodingEvents.ViewModels
{
   public class AddEventViewModel
   {
      public string? Name { get; set; } // ? makes property nullable
      public string? Description { get; set; }

// no constructor required for ViewModel, similar to DTO
   }
}

Declaring a value nullable
Do you see the ? after string in lines 7 and 8 in the code block above? This declares this property to be a nullable value type. This means that the value of Name or Description is allowed to be null at some point.

A null value for either of these fields is not idea, but we need them to have this flexibility when we begin to add validation attributes later in this chapter. If the validation checks fail, a new event will not be added to the project’s data storage.

public IActionResult Index()
{
   List<Event> events = new List<Event>(EventData.GetAll());

   return View(events); // when sending a list directly to the view, we need to import the event model and  @model List<Event> for strong typing

}

//index view, to get rid of ViewBag
@using CodingEvents.Models
@model List<Event>

Wherever we used our ViewBag property, we can now use Model syntax. We want to count the number of Model objects, like we did with the ViewBag.
@if (Model.Count == 0)
@foreach (var evt in Model)

Updating Add view with asp anchor tags:
@using CodingEvents.ViewModels
@model AddEventViewModel

//asp-for uses the given Model

<form asp-controller="Events" asp-action="Add" method="post"> // EventsController, Add() method, POST
    <div class="form-group">
        <label asp-for="Name">Event Name</label> //asp-for uses the Model
        <input asp-for="Name"/>
    </div>
    <div class="form-group">
        <label asp-for="Description">Description</label>
        <input asp-for="Description" />
    </div>
    <input type="submit" value="Add Event" />
</form>

Validation Attribtes:
[Required]	Specifies that a field cannot be null	[Required]
[Range]		Specifies the range of potential values of a numeric field.	[Range(0,100)]
[StringLength]	Specifies the maximum length of a string field. Has additional optional parameters to specify the minimum length of a string field.	[StringLength(100)]
[EmailAddress]	Specifies that a string field should conform to email formatting standards.	[EmailAddress]


ModelState.IsValid is a property of the controller class.
 if (ModelState.IsValid)
 {

 }

For view error handling: //jquery
        <main role="main" class="pb-3">
            @RenderBody()
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-validate/1.19.3/jquery.validate.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-validation-unobtrusive/3.2.12/jquery.validate.unobtrusive.js"></script>
        </main>

asp-validation-for // shows viewModel error messages if they are present

 <div asp-controller="Events" asp-action="Add" class="form-group">
     <label asp-for="Name"></label>
     <input asp-for="Name" class="form-control"/>
     <span asp-validation-for="Name" class="text-danger"></span>  // if present, use a jquery class to style the message
 </div>


full form: //with validation and error messages
<form asp-controller="Events" asp-action="Add" method="post">
    <div class="form-group">
        <label asp-for="Name">Event Name</label>
        <input asp-for="Name"/>
        <span asp-validation-for="Name" class="text-danger"></span>
    </div>
    <div class="form-group">
        <label asp-for="Description">Description</label>
        <input asp-for="Description" />
        <span asp-validation-for="Description" class="text-danger"></span>
    </div>
    <div class="form-group">
        <label asp-for="Email">Email</label>
        <input type="email" asp-for="Email" />
        <span asp-validation-for="Email" class="text-danger"></span>
    </div>
    <input type="submit" value="Add Event" />
</form>

To pass an object in while specifying the view.
return View("ViewName", objectName);

Enums:
Good for forcing values to reduce variance and errors in data.

	
   enum Day
   {
      Sunday,
      Monday,
      Tuesday,
      Wednesday,
      Thursday,
      Friday,
      Saturday
   }

same thing.

   public class DayConst
   {
      public const int Sunday = 0;
      public const int Monday = 1;
      public const int Tuesday = 2;
      public const int Wednesday = 3;
      public const int Thursday = 4;
      public const int Friday = 5;
      public const int Saturday = 6;
   }

Add an enum to a SelectListItem for transfer into the view.
   public List<SelectListItem> EventTypes { get; set; } = new List<SelectListItem>
   {
      new SelectListItem(EventType.Conference.ToString(), ((int)EventType.Conference).ToString()),
      new SelectListItem(EventType.Meetup.ToString(), ((int)EventType.Meetup).ToString()),
      new SelectListItem(EventType.Social.ToString(), ((int)EventType.Social).ToString()),
      new SelectListItem(EventType.Workshop.ToString(), ((int)EventType.Workshop).ToString())
   };

SelectListItem is an ASP.NET-provided class that represents each <option> element in a <select> element. The SelectListItem constructor requires a Text and Value property assignment. The Text property sets the displayed text in the <option> tag. This is created by getting each EventType and casting it to a string type. The Value property sets the value attribute on the <option> tag. This is created by getting each EventType, casting it to its implicit int value, and then casting that to a string type.

This list only exists in AddEventViewModel because we need it only for the purposes of displaying all of the options. We do not need a list of the different event types in our Event model. We just need the type of one event. This is another great reason to use a ViewModel!

asp-items: // to display list of options in select element
    <div class="form-group">
        <label asp-for="Type">Event Type</label>
        <select asp-for="Type" asp-items="Model.EventTypes"></select>
    </div>

Object-Relational Mapping:
Object-Relational Mapping or ORM is a technique for converting data between C# objects and relational databases. ORM converts data between two incompatible type systems (C# and MySQL), such that each model class becomes a table in our database and each instance a row of the table.

ORM in ASP.NET: DbContext
One of the most widely used object-relational mappers available for C# and ASP.NET Core is Entity Framework Core. This framework makes use of data layers. When we learned about models, we learned that data layers add abstraction between models and the data we want to store. With Entity FrameworkCore, data layers take the form of classes that extend DbContext.

To set up the Entity Framework Core. // install
cd to project folder, run
dotnet ef
if nothing comes up,
dotnet tool install -g dotnet-ef

To connect a db in csharp:
in Program.cs
   var connectionString = "server=localhost;user=username;password=password;database=database";
   var serverVersion = new MySqlServerVersion(new Version(#, #, #));

To install Db and associated packages: // make sure all versions match. ie 8 might not work with 7
https://education.launchcode.org/csharp-web-dev-curriculum/orm-part-1/reading/connecting-to-db/index.html

Pomelo.EntityFrameworkCore.MySql. This dependency provides code that is able to connect to a MySQL database from within an ASP.NET Core application using EF.
Microsoft.EntityFrameworkCore.Relational. This is a mapping framework that automates access and storage of data in your project’s database.
Microsoft.EntityFrameworkCore.Design. This helps manage data migrations and the design-time logic.


Create DbContext:
namespace CodingEvents.Data
{
    public class EventDbContext : DbContext
    {
        public DbSet<Event> Events { get; set; } // DbContext is typically paired with DbSet which represents the collection of entities that we want to query through
                                          // this allows us to query our Event objects

        public EventDbContext(DbContextOptions<EventDbContext> options) : base(options) // the constructor extends DbContextOptions which helps configure the data store
        {                                                                               // pass DbContextOptions of EventDbContext types to DbContext //allows us to inherit from DbContextOptions
        }
    }
}

Register a Data Store, DbContext: 
create a service in Program.cs. Services start everytime Program is run.
var connectionString = "server=localhost;user=username;password=password;database=coding-events-c-sharp";
var serverVersion = new MySqlServerVersion(new Version(8, 0, 33));

builder.Services.AddDbContext<EventDbContext>(dbContextOptions => dbContextOptions.UseMySql(connectionString, serverVersion)); // add this service to connect to our SQL server to update everytime we add to DbContext

The Entity Framework sets the ID for us

Now we need to set up our Migrations:
Our application is now completely configured to store Event objects in our MySQL database. However, if you look at the coding-events database, you’ll notice that it has no table in which to store such data. To create such a table, we need to create and run a database migration. A database migration (or migration, for short) is an update to a database made in order to reflect changes in an application’s model. Every time we change our application’s model by adding or removing a new persistent class, or by modifying a persistent class, we will need to create and run a migration.

Add a migration:
// install dotnet ef // dotnet tool install -g dotnet-ef
dotnet ef migrations add Init
dotnet ef database update // sends the new migration to the database and creates the tables


Use constructor injection to access the database in the controller or other classes:

        private EventDbContext context;

        public EventsController(EventDbContext dbcontext) // use contructor injection to populate context with our Entity
        {
            context = dbcontext;
        }

Access the entire db:
List<Event> events = context.Events.ToList();

Add to db:
context.Events.Add(freshEvent);
context.SaveChanges(); // must save

Remove from db:
                Event? anEvent = context.Events.Find(i); //look up event with an Id and see if it's there
                if (anEvent != null)
                {
                    context.Events.Remove(anEvent);
                    context.SaveChanges();
                }

Edit an event:
            Event? editEvent = context.Events.Find(eventId);
            if (editEvent != null)
            {
                editEvent.Name = name;
                editEvent.Description = description;
                context.SaveChanges();

A Primer on Lambda Expressions:
A lambda expression is an inline function defined using the symbol =>
argument => return expression

Select Example of a Lambda: (transforms/doubles the numbers in the return expression)
    int[] nums = {1, 2, 3, 4};
    var doubledNums = nums.Select(x => 2*x);
    Console.WriteLine(string.Join(" ", doubledNums));
    // output 2 4 6 8	

Where Example:
    int[] nums = {1, 2, 3, 4};
    var evens = nums.Where(x => (x % 2 == 0));
    Console.WriteLine(string.Join(" ", evens));
    // output 2 4

Setting up One-To-Many Relationship:
// in Event
public EventCategory Category { get; set; }
public int CategoryId { get; set; } // acts as foreign key
One-to-many relationships are established at the database level by the use of a foreign key column on one side of the relationship. Our Events table has a foreign key column: CategoryId.
For each Events row, the column CategoryId contains the Id of a Categories row. This is the primary key of the row in Categories that the Events row is related to. The Event/EventCategory relationship is many-to-one, so many event rows may have the same CategoryId value.

The CategoryId property functions as a foreign key. EF will create a CategoryId column in the Event table. The value of this column for a given row will determine which row in the Category table is related to the given event. Our code is now set up so that each Event will know about its EventCategory object, and that relationship persists.
It is very important that the ID field corresponding to the Category property is named CategoryId. This naming convention lets EF know that it should set Category to be the object with the Id value the same as CategoryId.

Defining the Inverse Relationship:
//in EventCategory
public List<Event> Events { get; set; }
The new property on Event is a single EventCategory reference, while the new property on EventCategory is a collection of Event objects. This is due to the one-to-many nature of the relationship. Each Event can have only one EventCategory, but an EventCategory may be related to multiple Event objects.

Lazy Loading: (default in EF)
lazy loading only loads the object requested and not other reference objects stored in other tables.
While lazy loading is not what we want now, it can be a useful strategy in a lot of cases. Suppose your application wants to display a list of all users, where each User has a UserDetails property that stores info like profile image, email, etc.
If all we need is a list of users, loading all of the additional data in UserProfile is unnecessary and will slow down the application. Lazy loading minimizes the data returned to optimize performance and reduce queries.

Eager Loading:
The solution is to use eager loading. Eager loading is a technique that allows us to specify that data from other tables/objects be loaded when the querying a specific table/object. 
List<Event> events = context.Events.Include(e => e.Category).ToList(); // in the controller
The Include method takes a lambda expression which specifies the property of each Event object that should be included in the query results. The effect of this additional method is that a JOIN query is performed between the Event and EventCategory tables, with Event.CategoryId being joined on EventCategory.Id.


Example of a Path Variable using default mapping:

public IActionResult Detail(int id) // if named id, will work as path variable
{
   Event theEvent = context.Events
      .Include(e => e.Category)
      .Single(e => e.Id == id);

   EventDetailViewModel viewModel = new EventDetailViewModel(theEvent);
   return View(viewModel);
}

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
This template is "{controller=Home}/{action=Index}/{id?}". The last portion, {id?}, means that any path parameter following the action method will map to a method parameter named id.
If we wanted to use a different URL structure, or a different method parameter name, we would need to include additional configuration. See the documentation on routing for more details.

EF method Single:
Event theEvent = context.Events
   .Include(e => e.Category)
   .Single(e => e.Id == id);
This method takes a boolean lambda expression and filters the Context.Events collection down to the one event that satisfies e.Id == id. In other words, it finds the single event with Id matching the path parameter.
We use Single instead of Find here because we also need to call Include to eagerly fetch the Category property. Include can not be chained with Find.

Many-To-Many Relationship: many to many
We need a Join Table inbetween our two tables.
A join table consists of two columns, each of which is a foreign key column to another table. Each row in a join table represents a relationship between one row in each of the two tables being joined. This technique enables many-to-many relationships.

To model a join table for Event and Tag classes, we will provide a collection navigation property on both sides of the relationship.
public ICollection<Tag>? Tags { get; set; }
Tags = new List<Tag>(); // in the constructor

public ICollection<Event>? Events { get; set; }
Events = new List<Event>(); // in the constructor

Join Entity Type Configuration: EventDbContext
	
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
   modelBuilder.Entity<Event>()
         .HasMany(e => e.Tags)
         .WithMany(e => e.Events)
         .UsingEntity(j => j.ToTable("EventTags"));
}
The method OnModelCreating can be overridden from the base class, DbContext, in order to provide additional configuration for the data store. In this case, we add code that configures EventTag to have a composite primary key consisting of the properties/columns EventId and TagId.

Example of creating a join table:
[HttpPost]
[Route("addevent")]
public IActionResult ProcessAddEvent(AddEventTagViewModel addEventTagViewModel)
{
    if (!ModelState.IsValid)
    {
        return View("AddEvent", addEventTagViewModel);
    }

    int eventId = addEventTagViewModel.EventId;
    int tagId = addEventTagViewModel.TagId;

    Event anEvent = context.Events
        .Include(e => e.Tags) // use include method for eager loading to include tags
        .Where(e => e.Id == eventId) // find our event
        .First(); //

    Tag aTag = context.Tags
        .Where(t => t.Id == tagId)
        .First();

    anEvent.Tags.Add(aTag); // add the tag to event
    context.SaveChanges(); // save all changes


    return Redirect("/event/detail/" + eventId);
}


A Note On Authentication In ASP.NET: Identity Framework
Professional developers working with ASP.NET use ASP.NET Core Identity for authentication.
Identity handles many aspects of the authentication process for you. This may hide steps that are important to understand as you learn about authentication.
Some of the inner workings of Identity are beyond the scope of this course. Do not fear when troubleshooting!
Identity has lots of different configuration options and can handle complex authentication setups.

Adding Identity to an exisiting project is known as Scaffolding.

Password hashing:
Identity uses IdentityV3 which uses PBKDF2 as it's hashing algorithm.













