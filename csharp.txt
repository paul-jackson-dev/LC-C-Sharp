Solution:

A solution is a container that holds different projects.

Typing:
Even though C# is a statically typed language, we can type variables as var and the compiler will infer the type. Aviod using var.

Built In Types: (primitive types)
In C#, all of the built in types are objects and have short names that break naming convention. We can also use the official .NET classname?

Short name	.NET Class	Examples	Notes
int		Int32		-5, 1024	
float		Single		1.212, 3.14	
double		Double		3.14159, 2.0	Doubles are twice as precise (i.e. can hold much longer decimal numbers than floats)
char		Char		‘a’, ‘!’	A single Unicode character. Must be enclosed in single quotes '' to be a character; double quotes "" indicate a string
bool		Boolean		true, false	Note that booleans in C# are not capitalized as they are in Python

Primitive types are immutable.


Non-primitive types
string is another built-in type in C# and it is also a non-primitive data type.

Numeric types such as int and double may be freely mixed when using numeric operators. 
Generally, the result of such mixing is that the output has the type of the more precise input. 

Reference and Value Types:
Value types: int, float, double, char, bool, (all other built in types)

Reference types: All Class Types. Dog myDog = new Dog();
Variables and parameters that are of the type of a class are said to be of reference type (in contrast to primitive type). In plain English, we would say of the C# example: “myDog is a reference variable of type Dog.
Classes define reference types. A variable of a reference type (such as myDog above) does not actually store the object in question. Instead, it stores a reference to the object. A reference is literally a memory address. We visualize references as an arrow pointing to the object in memory.

Boxing:
All types in C# are treated as objects. Even value types. This can be accomplished through processes called boxing and unboxing. Converting from a value type to a reference type is called boxing, and the reverse process (reference to value) is called unboxing. C# is known as a unified type system because it implicitly boxes values types to be treated as objects.

   int i = 123;     // This is a value type.
   object o = i;    // Boxing the value type into a reference type.
   int j = (int)o;  // Unboxing the reference type back into a value type.


using: (import statement)
The using statement in C# allows us to access classes, methods, and data stored in different files other than the one we are currently in.
assuming. 
	1. The C# compiler must know that the class exists.
	2. You must use the full name of the class.
Classes that are available may be those in the project you are currently working on, or those that come along with the .NET class library, as well as anything you might get from added dependencies.
System.Console can simply be access using Console. System is the namespace, Console is the class.

Input/Output:
Console.WriteLine can take parameters of various types, including string, char, double, bool, and others. We must manually concatenate strings or other values if we want to print a composite value.
   int year = 2020;
   Console.WriteLine("Hello" + "World")
   Console.WriteLine("The year is " + year.ToString());

Console.ReadLine returns input as a string.
To convert it to a desired type, you can generally use the syntax [TYPE].Parse(value
   string userInput = Console.ReadLine();
   int year = int.Parse(userInput); // use int type to cast parsed input

Strings, Characters, and Arrays:
Strings are immutable which means any given character cannot be changed.

String Methods:
@ initializes a string as a literal
string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";

C# Syntax		Description
str.Substring(3,1)	Returns the character in 3rd position, (a).
str.Substring(2,3)	Return substring from 2nd to 4th, i.e. substring starting at index 2 and 3 characters long, (tab).
str.Length		Tells us the length of the string, (8).
str.IndexOf('a')	Returns the index for the first occurrence of ‘a’, (3).
str.Split('a')		Splits the string into sections at each delimiter and stores the sections as elements in an array, ({Rut, b, g}).
str + str		Concatenate two strings together, (RutabagaRutabaga).
str.Trim()		Removes any whitespace at the beginning or end of the string, (Rutabaga — there’s not whitespace here).
str.ToUpper(), str.ToLower()	Changes all alphabetic characters in the string to UPPERCASE or lowercase, respectively,(RUTABAGA, rutabaga).

Arrays: (fixed size that cannot change)
int[] someInts = new int[10]; // stores an array of 10 integers
int[] someOtherInts = {1, 1, 2, 3, 5, 8}; // literal expression

Objects:
In C#, objects are structures that have a state and a set of behaviors. The state of an object includes properties/data that the coder can define and modify. Behaviors are actions that run when requested, and they can be used to evaluate, manipulate, or return data.

Static Methods:
Behave somewhat similarly to stand-alone functions. 
A static method is one that can be called without creating an object instance of the class to which it belongs.

Main() Methods:
Starting in .NET 6 the Main() method is synthesized.

Loops:

for Loop:
for (int i = 0; i < 10; i++ ) {
   Console.WriteLine(i);
}

foreach Loop:
int[] nums = {1, 1, 2, 3, 5, 8, 13, 21};

foreach (int n in nums) {
   Console.WriteLine(n);
}

string msg = "Hello World";

foreach (char c in msg.ToCharArray()) {
   Console.WriteLine(c);
}

while Loop:
int w = 0;
while (w < 3) {
   w++;
}

do-while Loop:
do {
   Console.WriteLine("Hello, World");
} while (false);

StringBuilder:
while something like sentence += word is fine, it can use a lot of resources if the sentence is long since strings are immutable and a new string object is created each iteration.
We can use the StringBuilder class to create a single object since it is mutable.

StringBuilder newFinalSentence = new StringBuilder();

foreach (string word in arrayOfWords) {
   newFinalSentence.Append(word);
}

Data Structures:
A data structure lets us hold on to lots of data in a single place. It is a programming construct to aggregate many values into one value. Many types of data structures exist in various languages. A few examples are lists, dictionaries, arrays, tuples, etc.

Collections:
using System.Collections.Generic;

List:
List<string> students = new List<string>();
students.Add(newStudent);
or 
List<string> newList = new List<string> {"Apples", "Oranges", "Avocados"};
students.Count // to get List length

List Methods in C#:
 .IndexOf()
 .Add()
 .Contains()
 .Sort()
 .ToArray()

Array:
Arrays are faster than List
int maxStudents = 30;
string[] students = new string[maxStudents];
students[i] = newStudent; // to add

Dictionary: Key/Value pair
Dictionary<string, double> students = new Dictionary<string, double>();
or 
Dictionary<int, string> groceries = new Dictionary<int, string>
{
   {2, "Apples"},
   {3, "Oranges"},
   {1, "Avocado"}
};
students.Add(newStudent, newGrade); // Key, Value

string name = "jesse";
double jesseGrade = students[name];

// for key and value
foreach (KeyValuePair<string, double> student in students) {
   Console.WriteLine(student.Key + " (" + student.Value + ")");
   sum += student.Value;
}

// for key
foreach (string studentName in students.Keys) {
   Console.WriteLine(studentName);
}

// for value
foreach (double grade in students.Values) {
   Console.WriteLine(grade);
}

Dictionary Methods in C#:
.Count
.Keys
.Values
.Add()
.ContainsKey()
.ContainsValue()

Access Modifiers:

Modifier			Class	Assembly	World
public				Yes	Yes		Yes
protected			Yes	No		No
internal (default for classes)	Yes	Yes		No
protected internal		Yes	Yes		No
private (default for class members)Yes	No		No

In C#, an assembly refers to a grouping of classes and other resources that form a particular unit of an application.
World-level is the level of the whole application and contains all of the packages and classes.
Getter setter methods are also often called accessors.

Getters Setters / Accessors:
   private string name;

   public string Name
   {
      get { return name; } // default is public?
      internal set { name = value; } // only set by class or assembly
   }

Example of Setter Validation: // throw ArgumentException
   public class Temperature 
   {

      private double fahrenheit;

      public double Fahrenheit
      {
         get
         {
            return fahrenheit;
         }

        set
        {
            double absoluteZeroFahrenheit = -459.67;

            if (value < absoluteZeroFahrenheit) 
            {
               throw new ArgumentException("Value is below absolute zero");
            }

            fahrenheit = value;
         }
      }
   }

Properties:
A property in C# is a characteristic that users can set. Most often, properties will correspond directly to a private backing field, but they don’t have to. 
   public double Celsius
   {
      get { return (Fahrenheit - 32) * 5.0 / 9.0; }
      set { Fahrenheit = value * 9.0 / 5.0 + 32; }
   }

Auto-Implemented Properties:
public string Name { get; set; } // shorthand if we don't need validation

This is referred to as an auto-implemented property. When a property is auto-implemented, the compiler creates a private field that can only be accessed through the property’s get and set accessors.
Note that in this example, the private field is name (lowercase) while the property is Name. Since C# identifiers are case-sensitive, these are two distinct members. name is referred to as a backing field, and it stores the value of the property.

Constructor Overloading: // providing different constructors for different scenarios
	
   public class Student 
   {

      public string Name { get; set; }
      public int StudentId { get; set; }
      public int NumberOfCredits { get; set; }
      public double Gpa { get; set; }

      public Student(string name, int studentId, int numberOfCredits, double gpa) 
      {
         Name = name;
         StudentId = studentId;
         NumberOfCredits = numberOfCredits;
         Gpa = gpa;
      }

      public Student(string name, int studentId) : this(name, studentId, 0, 0.0) {} // use this to call other constuctor, inheritance

   }

Instance Method with Constructor Overloading:
	
   public class Student 
   {

      private static int nextStudentId = 1;
      public string Name { get; set; }
      public int StudentId { get; set; }
      public int NumberOfCredits { get; set; }
      public double Gpa { get; set; }

      public Student(string name, int studentId,
            int numberOfCredits, double gpa)
      {
         Name = name;
         StudentId = studentId;
         NumberOfCredits = numberOfCredits;
         Gpa = gpa;
      }

      public Student(string name, int studentId)
        : this(name, studentId, 0, 0) {}

      public Student(string name) 
         : this(name, nextStudentId)
      {
         nextStudentId++;
      }

      public string StudentInfo() 
      {
         return (Name + " has a GPA of: " + Gpa);
      }

   }

Single Responsibility Principle:
The single responsibility principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class.


Readonly Fields:
A readonly field is one that cannot be changed once it is initialized. This means slightly different things for value and reference types. We create readonly fields by declaring them with the readonly keyword.

We cannot change the value of a readonly value field (readonly int, readonly double, etc.) after it is initialized.

Similarly, we cannot assign a new object to a readonly reference field (readonly ClassName, for example) after initialization. However, because objects are reference types and not value types, we can change the values within the object itself.

Const:
There is no strong reason to make constants private, since restricting access would force us to re-declare the same values in different classes. We’ll generally make our constants public.

We must declare and initialize a constant at the same time. If we do not declare and initialize the constant in the same statement, we cannot assign it a value later. The constant’s value remains empty

Const vs Readonly:
Const is a compile-time constant, while readonly is a runtime constant. Const values are implicitly static and limited to basic types, while readonly variables can be instance, static, or reference types. Const variables are stored in metadata and readonly variables are stored in the memory heap.

Instance Methods:
Instance methods define the behaviors that are unique or specialized to each class. Every object created from a class will carry a copy of these methods.
Instance methods depend on the data stored in an individual object. If two objects call the same method, the results will vary when the objects contain different data.

Static Methods:
Just like static fields, static methods belong to the class as a whole, and not to any of the specific instances of the class. Thus, they are sometimes also called class methods. A static method is essentially the opposite of an instance method, since the two cases are mutually exclusive. Instance methods rely on each object’s specific data, while static methods must NOT rely on data from a specific object.

It is technically allowed to call a static method using an instance of a class: myObject.SomeStaticMethod(). However, best practice recommends using the class name instead: ClassName.SomeStaticMethod(). This makes it clear to other coders that you are calling a static method.

Equals():
If we don’t provide our own Equals() method, the default option only considers two objects equal if they are the exact same object, which means they point to the same memory address. This is identical to the behavior we see when using the == operator: bono1 == bono2.
The default Equals() method and the == operator test for identity, whereas we want to test for equality instead. We can do so by overriding the Equals() method.

	
public override boolean Equals(object toBeCompared) {

   if (toBeCompared == this)
   {
      return true;
   }

   if (toBeCompared == null)
   {
      return false;
   }

   if (toBeCompared.GetType() != this.GetType())
   {
      return false;
   }

   Student s = toBeCompared as Student;
   return s.StudentId == StudentId;
}

Reference check: If the two objects are the same, return true right away.
Null check: If the argument is null, return false.
Class check: Compare the classes of the two objects to ensure a safe cast. Return false if the classes are different.
Cast: Convert the argument to the type of our class, so getters and other methods can be called.
Custom comparison: Use custom logic to determine whether or not the two objects should be considered equal. This will usually be a comparison of class members.

Auto-Generated .Equals():
   public override bool Equals(object obj)
   {
      return obj is Course course && // With is, the compiler confirms that it is possible to cast obj to a variable course of type Course. If it is, the value of course is set to obj.
         Topic == course.Topic &&
         EqualityComparer<Teacher>.Default.Equals(Instructor, course.Instructor);
   }

Cast/Casting: //example
Student s = toBeCompared as Student;

































